---
title: Connecting Digital Systems and Operating System
sidebar:
  label: 'Overview'
---

import { YouTube } from 'astro-embed';

In previous modules, we explored the fundamentals of electronics, logic gates, and computer architecture. We've worked with both the Raspberry Pi 4B as a single-board computer and the Raspberry Pi Pico 2W as a microcontroller. Now, it's time to connect these worlds together and understand how different digital systems communicate with each other.

This module focuses on:

- **Operating Systems**: Understanding what they do and their role in managing hardware
- **Communication Protocols**: Learning about serial and parallel data transmission
- **Connecting Devices**: Practical methods for connecting Raspberry Pi 4B and Pico 2W
- **Wireless Communication**: Using WiFi and Bluetooth to create wireless connections
- **Building a Connected System**: Integrating everything into a functional project

By the end of this module, you'll understand not just individual components, but how they work together in comprehensive digital systems.


## Extra: Building a Complete System

Now that we've explored various ways to connect our Raspberry Pi 4B and Pico 2W, let's integrate these techniques into a more comprehensive project.

:::tip[Capstone Project: Smart Home Monitoring System]

In this project, we'll build a complete IoT system that:

1. Uses the Pico 2W to collect environmental data
2. Processes and stores that data on the Raspberry Pi 4B
3. Provides a web interface to monitor and control the system

**System Architecture:**

![Smart Home System Architecture](../2-computers/images/pico/pico.png)
_System architecture showing data flow between components_

**Components Needed:**

- Raspberry Pi 4B
- Raspberry Pi Pico 2W
- DHT22 temperature and humidity sensor
- LED (already on the Pico 2W)
- Jumper wires

**Step 1: Setting Up the Pico 2W Sensor Node**

Connect the DHT22 sensor to the Pico 2W:

- VCC to 3.3V (3V3 pin)
- GND to ground
- Data to GP28

Program the Pico 2W with this code:

```python
# sensor_node.py for Pico 2W
import network
import socket
import time
import json
import machine
from machine import Pin
import dht

# WiFi credentials
SSID = 'YourNetworkName'
PASSWORD = 'YourPassword'

# Set up DHT22 sensor
dht_sensor = dht.DHT22(Pin(28))

# Set up status LED
led = Pin("LED", Pin.OUT)

# Server details (Raspberry Pi 4B)
SERVER_IP = '192.168.1.100'  # Replace with your Pi's IP
SERVER_PORT = 8080

# Connect to WiFi
def connect_wifi():
    wlan = network.WLAN(network.STA_IF)
    wlan.active(True)
    wlan.connect(SSID, PASSWORD)

    # Wait for connection with timeout
    max_wait = 10
    while max_wait > 0:
        if wlan.status() < 0 or wlan.status() >= 3:
            break
        max_wait -= 1
        print('Waiting for connection...')
        led.toggle()
        time.sleep(1)

    if wlan.status() != 3:
        led.value(0)
        raise RuntimeError('Network connection failed')
    else:
        led.value(1)
        print('Connected')
        print('IP address:', wlan.ifconfig()[0])

    return wlan

# Read sensor data
def read_sensor():
    try:
        dht_sensor.measure()
        temp = dht_sensor.temperature()
        humidity = dht_sensor.humidity()
        return {
            'temperature': temp,
            'humidity': humidity,
            'timestamp': time.time(),
            'device_id': 'pico_sensor_1'
        }
    except Exception as e:
        print('Sensor read error:', e)
        return None

# Send data to server
def send_data(data):
    try:
        # Create a socket
        s = socket.socket()
        # Connect to server
        s.connect((SERVER_IP, SERVER_PORT))
        # Convert data to JSON
        json_data = json.dumps(data)
        # Send data
        s.send(json_data.encode())
        # Receive response
        response = s.recv(1024).decode()
        print('Server response:', response)
        # Close socket
        s.close()
        # Blink LED to indicate successful transmission
        led.value(0)
        time.sleep(0.1)
        led.value(1)
        return True
    except Exception as e:
        print('Send error:', e)
        # Rapid blink to indicate error
        for _ in range(5):
            led.toggle()
            time.sleep(0.1)
        led.value(1)
        return False

# Main program
try:
    # Connect to WiFi
    wlan = connect_wifi()

    # Run forever
    while True:
        # Read sensor data
        sensor_data = read_sensor()
        if sensor_data:
            # Send data to server
            send_data(sensor_data)

        # Wait before next reading (every 5 minutes)
        time.sleep(300)

except KeyboardInterrupt:
    print('Program stopped')
```

You'll need to install the DHT library on the Pico 2W:

1. Download `dht.py` from MicroPython libraries
2. Upload it to the Pico 2W using Thonny

**Step 2: Setting Up the Raspberry Pi 4B Server**

Create a server script on the Raspberry Pi 4B:

```python
# sensor_server.py for Raspberry Pi 4B
import socket
import json
import time
import sqlite3
from datetime import datetime
import threading
from flask import Flask, jsonify, render_template

# Database setup
def setup_database():
    conn = sqlite3.connect('sensor_data.db')
    cursor = conn.cursor()
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS readings (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        device_id TEXT,
        temperature REAL,
        humidity REAL,
        timestamp INTEGER,
        recorded_at TEXT
    )
    ''')
    conn.commit()
    conn.close()
    print("Database initialized")

# Function to store data in database
def store_data(data):
    conn = sqlite3.connect('sensor_data.db')
    cursor = conn.cursor()
    now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    cursor.execute('''
    INSERT INTO readings (device_id, temperature, humidity, timestamp, recorded_at)
    VALUES (?, ?, ?, ?, ?)
    ''', (
        data['device_id'],
        data['temperature'],
        data['humidity'],
        data['timestamp'],
        now
    ))
    conn.commit()
    conn.close()
    print(f"Data stored: Temp={data['temperature']}°C, Humidity={data['humidity']}%")

# Socket server to receive data from Pico 2W
def run_socket_server():
    server_socket = socket.socket()
    server_socket.bind(('0.0.0.0', 8080))
    server_socket.listen(5)
    print("Socket server started on port 8080")

    while True:
        client, addr = server_socket.accept()
        print(f"Connection from: {addr}")
        data = client.recv(1024).decode()
        try:
            sensor_data = json.loads(data)
            print(f"Received data: {sensor_data}")
            store_data(sensor_data)
            client.send(b"Data received successfully")
        except json.JSONDecodeError:
            print(f"Invalid data: {data}")
            client.send(b"Error: Invalid data format")
        except Exception as e:
            print(f"Error processing data: {e}")
            client.send(b"Error processing data")
        finally:
            client.close()

# Flask web server to display data
app = Flask(__name__)

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/api/data')
def get_data():
    conn = sqlite3.connect('sensor_data.db')
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    cursor.execute('''
    SELECT * FROM readings ORDER BY timestamp DESC LIMIT 100
    ''')
    data = [dict(row) for row in cursor.fetchall()]
    conn.close()
    return jsonify(data)

@app.route('/api/latest')
def get_latest():
    conn = sqlite3.connect('sensor_data.db')
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    cursor.execute('''
    SELECT * FROM readings ORDER BY timestamp DESC LIMIT 1
    ''')
    data = dict(cursor.fetchone())
    conn.close()
    return jsonify(data)

# Main program
if __name__ == '__main__':
    # Setup database
    setup_database()

    # Start socket server in a separate thread
    socket_thread = threading.Thread(target=run_socket_server)
    socket_thread.daemon = True
    socket_thread.start()

    # Start web server
    print("Starting web server...")
    app.run(host='0.0.0.0', port=5000, debug=True)
```

Create a simple HTML template in `templates/index.html`:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Smart Home Monitoring</title>
    <meta http-equiv="refresh" content="60" />
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
      }
      .reading-card {
        background-color: #f5f5f5;
        border-radius: 10px;
        padding: 20px;
        margin-bottom: 20px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      }
      .current-reading {
        display: flex;
        justify-content: space-between;
      }
      .reading-value {
        font-size: 48px;
        font-weight: bold;
        text-align: center;
      }
      .reading-label {
        font-size: 14px;
        color: #666;
        text-align: center;
      }
      .temperature {
        color: #e63946;
      }
      .humidity {
        color: #457b9d;
      }
      #chart-container {
        height: 400px;
        margin-top: 40px;
      }
      h1,
      h2 {
        color: #1d3557;
      }
    </style>
  </head>
  <body>
    <h1>Smart Home Monitoring System</h1>

    <div class="reading-card">
      <h2>Current Readings</h2>
      <div class="current-reading">
        <div>
          <div id="current-temp" class="reading-value temperature">--°C</div>
          <div class="reading-label">Temperature</div>
        </div>
        <div>
          <div id="current-humidity" class="reading-value humidity">--%</div>
          <div class="reading-label">Humidity</div>
        </div>
      </div>
      <p id="last-updated">Last updated: --</p>
    </div>

    <div class="reading-card">
      <h2>Historical Data</h2>
      <div id="chart-container">
        <canvas id="chart"></canvas>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
      // Fetch latest reading
      fetch('/api/latest')
        .then((response) => response.json())
        .then((data) => {
          document.getElementById('current-temp').textContent = data.temperature.toFixed(1) + '°C';
          document.getElementById('current-humidity').textContent = data.humidity.toFixed(1) + '%';
          const date = new Date(data.timestamp * 1000);
          document.getElementById('last-updated').textContent = 'Last updated: ' + date.toLocaleString();
        });

      // Fetch historical data and create chart
      fetch('/api/data')
        .then((response) => response.json())
        .then((data) => {
          // Process data for chart
          const labels = data
            .map((item) => {
              const date = new Date(item.timestamp * 1000);
              return date.toLocaleTimeString();
            })
            .reverse();

          const temperatures = data.map((item) => item.temperature).reverse();
          const humidities = data.map((item) => item.humidity).reverse();

          // Create chart
          const ctx = document.getElementById('chart').getContext('2d');
          const chart = new Chart(ctx, {
            type: 'line',
            data: {
              labels: labels,
              datasets: [
                {
                  label: 'Temperature (°C)',
                  data: temperatures,
                  borderColor: '#e63946',
                  backgroundColor: 'rgba(230, 57, 70, 0.1)',
                  tension: 0.3,
                },
                {
                  label: 'Humidity (%)',
                  data: humidities,
                  borderColor: '#457b9d',
                  backgroundColor: 'rgba(69, 123, 157, 0.1)',
                  tension: 0.3,
                },
              ],
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                y: {
                  beginAtZero: false,
                },
              },
            },
          });
        });
    </script>
  </body>
</html>
```

**Step 3: Running the Complete System**

1. Install required packages on the Raspberry Pi 4B:

   ```bash
   sudo apt update
   sudo apt install python3-flask python3-sqlite3
   ```

2. Create the templates directory and save the HTML file:

   ```bash
   mkdir -p templates
   # Create the index.html file inside templates directory
   ```

3. Start the server on the Raspberry Pi 4B:

   ```bash
   python3 sensor_server.py
   ```

4. Power up the Pico 2W with the sensor program

5. Open a web browser and navigate to:
   ```
   http://[RaspberryPi_IP]:5000
   ```
   Where `[RaspberryPi_IP]` is the IP address of your Raspberry Pi 4B

**What You've Accomplished:**

This project integrates nearly all the concepts we've covered in this module:

1. **Operating System Concepts**:

   - Using the OS to manage processes (threading in the server)
   - File system for storing data (SQLite database)
   - Network stack for communication

2. **Communication Protocols**:

   - WiFi networking between devices
   - Socket-based communication
   - HTTP for the web interface

3. **Sensors and Actuators**:

   - Reading environmental data
   - Visual feedback through LEDs

4. **Data Management**:

   - Collecting and storing sensor data
   - Visualizing time-series data

5. **System Integration**:
   - Connecting multiple devices with different capabilities
   - Creating a complete end-to-end system

This demonstrates a typical IoT architecture with sensor nodes (Pico 2W) collecting data and sending it to a central hub (Raspberry Pi 4B) that processes, stores, and presents the information to users.

:::
